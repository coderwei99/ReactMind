## 设计文档

### 拖拽过程所可能的情况
  首先明确几个概念,以根节点为中心,思维导图可以划分为左右两部分,左边部分在下面称为左节点,右边部分称为右节点 
1. 拖动左边的元素
  - 最终目标点在左边
    > 计算方式: 小于根节点的offsetLeft 并且  小于
  - 最终目标点在右边
2. 拖动右边的元素
  - 最终目标点在左边
  - 最终目标点在右边

### 如果计算拖动元素究竟要被移动到那个元素前面?
1. ~~我们首先可以拿到的是拖动的元素,这一点是完全没问题的,用户拖动的那个元素是可以dragstart事件中获取到的~~
2. ~~然后就是重点了,根据用户松开鼠标的坐标(x,y)来确定目标元素,然后将这个拖动元素移动到目标元素前面~~
    - ~~为了确定目标元素,我们需要先用一个Map,保存着所有节点的位置信息(距离屏幕顶部的位置,距离屏幕左侧的位置,自身宽高等等一切利于我们寻找目标节点的信息)~~
    - ~~这就有个前提: 上面根据用户松开鼠标的坐标(x,y)和我们预先保存节点位置信息的时候他们计算的**基准**要一致,就是说他们要有统一的参照点,别一个根据屏幕来计算,一个根据父元素(思维导图的容器)来计算,这样就会出现问题~~
3. ~~目前敲定统一以思维导图的容器为基准,也就是id为xmind-wrapper的容器~~
传新版本:
 - 根据drop事件的e.target.id直接拿到目标元素的节点id,这个id我们在渲染的时候绑定的就是节点树的id